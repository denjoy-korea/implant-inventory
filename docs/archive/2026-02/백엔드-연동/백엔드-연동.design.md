# Design: 백엔드-연동

> localStorage 기반 시스템을 Supabase 백엔드로 마이그레이션하는 상세 설계

## 1. 아키텍처 개요

### 1.1 현재 아키텍처 (As-Is)

```
┌─────────────────────────────────────────────┐
│                React App                     │
│  ┌─────────┐  ┌──────────┐  ┌────────────┐ │
│  │ AuthForm │  │ App.tsx  │  │ Components │ │
│  │ (직접    │  │ (상태    │  │ (UI 렌더)  │ │
│  │  인증)   │  │  관리)   │  │            │ │
│  └────┬─────┘  └────┬─────┘  └────┬───────┘ │
│       │             │             │          │
│  ┌────▼─────────────▼─────────────▼───────┐ │
│  │         localStorage (병원별 prefix)     │ │
│  │  app_user, app_users, app_hospitals     │ │
│  │  hospital_{id}_app_inventory            │ │
│  │  hospital_{id}_app_surgery_master       │ │
│  │  hospital_{id}_app_orders               │ │
│  │  hospital_{id}_app_fixture_data         │ │
│  └────────────────────────────────────────┘ │
└─────────────────────────────────────────────┘
```

### 1.2 목표 아키텍처 (To-Be)

```
┌──────────────────────────────────────────────────────────┐
│                     React App                             │
│                                                          │
│  ┌── Presentation Layer ──────────────────────────────┐  │
│  │ AuthForm  App.tsx  InventoryManager  OrderManager  │  │
│  │ FailManager  MemberManager  DashboardOverview ...  │  │
│  └──────────────────┬─────────────────────────────────┘  │
│                     │                                     │
│  ┌── Hook Layer ────▼─────────────────────────────────┐  │
│  │ useAuth()  useHospital()  useInventory()           │  │
│  │ useSurgery()  useOrders()  useRealtime()           │  │
│  └──────────────────┬─────────────────────────────────┘  │
│                     │                                     │
│  ┌── Service Layer ─▼─────────────────────────────────┐  │
│  │ authService  hospitalService  inventoryService     │  │
│  │ surgeryService  orderService  migrationService     │  │
│  └──────────────────┬─────────────────────────────────┘  │
│                     │                                     │
│  ┌── Client Layer ──▼─────────────────────────────────┐  │
│  │ supabaseClient.ts (@supabase/supabase-js v2)       │  │
│  └──────────────────┬─────────────────────────────────┘  │
└─────────────────────│─────────────────────────────────────┘
                      │ HTTPS (REST + Realtime WebSocket)
┌─────────────────────▼─────────────────────────────────────┐
│                   Supabase Cloud                           │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │   Auth   │  │ Database │  │ Storage  │  │ Realtime │ │
│  │  (JWT)   │  │ (PgSQL)  │  │ (S3)     │  │ (WS)    │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Row Level Security (RLS) - 병원별 데이터 격리       │ │
│  └─────────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────┘
```

### 1.3 레이어 책임

| Layer | 책임 | 파일 |
|-------|------|------|
| Presentation | UI 렌더링, 사용자 입력 처리 | `components/*.tsx`, `App.tsx` |
| Hook | 상태 관리, Supabase 서비스 호출 조합 | `hooks/useAuth.ts` 등 (Phase 2에서 도입) |
| Service | Supabase CRUD 캡슐화, 비즈니스 로직 | `services/*Service.ts` |
| Client | Supabase 연결 설정, 환경 변수 | `services/supabaseClient.ts` |

## 2. 데이터베이스 스키마

### 2.1 ERD

```
┌──────────────┐       ┌──────────────┐
│  auth.users  │       │  hospitals   │
│──────────────│       │──────────────│
│ id (UUID) PK │◄──┐   │ id (UUID) PK │
│ email        │   │   │ name         │
│ ...          │   │   │ master_admin │──┐
└──────────────┘   │   │ phone        │  │
                   │   │ biz_file_url │  │
                   │   │ created_at   │  │
                   │   └──────┬───────┘  │
                   │          │1         │
                   │          │          │
              ┌────┴──────────▼──┐       │
              │    profiles      │       │
              │──────────────────│       │
              │ id (UUID) PK/FK │◄──────┘
              │ email            │
              │ name             │
              │ role             │
              │ hospital_id FK   │
              │ status           │
              │ created_at       │
              └──────┬───────────┘
                     │
    ┌────────────────┼────────────────┐
    │                │                │
┌───▼──────────┐ ┌──▼───────────┐ ┌──▼──────────┐
│  inventory   │ │surgery_records│ │   orders    │
│──────────────│ │──────────────│ │─────────────│
│ id PK        │ │ id PK        │ │ id PK       │
│ hospital_id  │ │ hospital_id  │ │ hospital_id │
│ manufacturer │ │ date         │ │ type        │
│ brand        │ │ patient_info │ │ manufacturer│
│ size         │ │ tooth_number │ │ date        │
│ initial_stock│ │ quantity     │ │ manager     │
│ created_at   │ │ surgery_rec  │ │ status      │
│ updated_at   │ │ classification│ │ received_dt │
└──────────────┘ │ manufacturer │ │ created_at  │
                 │ brand        │ └──────┬──────┘
                 │ size         │        │1
                 │ bone_quality │        │
                 │ init_fixation│  ┌─────▼──────┐
                 │ healing      │  │order_items  │
                 │ next_visit   │  │─────────────│
                 │ created_at   │  │ id PK       │
                 └──────────────┘  │ order_id FK │
                                   │ brand       │
                                   │ size        │
                                   │ quantity    │
                                   └─────────────┘
```

### 2.2 완전 SQL 스키마

```sql
-- ============================================
-- 1. hospitals 테이블
-- ============================================
CREATE TABLE hospitals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  master_admin_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  phone TEXT,
  biz_file_url TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- ============================================
-- 2. profiles 테이블 (auth.users 확장)
-- ============================================
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  role TEXT NOT NULL DEFAULT 'staff' CHECK (role IN ('master', 'dental_staff', 'staff')),
  hospital_id UUID REFERENCES hospitals(id) ON DELETE SET NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'active')),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- 신규 사용자 등록 시 profiles 자동 생성 (트리거)
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO profiles (id, email, name, role, status)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'name', ''),
    COALESCE(NEW.raw_user_meta_data->>'role', 'staff'),
    CASE
      WHEN NEW.raw_user_meta_data->>'role' = 'master' THEN 'active'
      ELSE 'pending'
    END
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- ============================================
-- 3. inventory 테이블
-- ============================================
CREATE TABLE inventory (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hospital_id UUID NOT NULL REFERENCES hospitals(id) ON DELETE CASCADE,
  manufacturer TEXT NOT NULL,
  brand TEXT NOT NULL,
  size TEXT NOT NULL,
  initial_stock INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_inventory_hospital ON inventory(hospital_id);
CREATE INDEX idx_inventory_manufacturer ON inventory(hospital_id, manufacturer);

-- ============================================
-- 4. surgery_records 테이블
-- ============================================
CREATE TABLE surgery_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hospital_id UUID NOT NULL REFERENCES hospitals(id) ON DELETE CASCADE,
  date DATE,
  patient_info TEXT,
  tooth_number TEXT,
  quantity INTEGER DEFAULT 1,
  surgery_record TEXT,
  classification TEXT DEFAULT '식립' CHECK (
    classification IN ('식립', '골이식만', '수술중교환', '청구', '교환완료')
  ),
  manufacturer TEXT,
  brand TEXT,
  size TEXT,
  bone_quality TEXT,
  initial_fixation TEXT,
  healing TEXT,
  next_visit TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_surgery_hospital ON surgery_records(hospital_id);
CREATE INDEX idx_surgery_date ON surgery_records(hospital_id, date);
CREATE INDEX idx_surgery_classification ON surgery_records(hospital_id, classification);

-- ============================================
-- 5. orders 테이블
-- ============================================
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hospital_id UUID NOT NULL REFERENCES hospitals(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('replenishment', 'fail_exchange')),
  manufacturer TEXT NOT NULL,
  date DATE NOT NULL,
  manager TEXT NOT NULL,
  status TEXT DEFAULT 'ordered' CHECK (status IN ('ordered', 'received')),
  received_date DATE,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_orders_hospital ON orders(hospital_id);
CREATE INDEX idx_orders_status ON orders(hospital_id, status);

-- ============================================
-- 6. order_items 테이블
-- ============================================
CREATE TABLE order_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  brand TEXT NOT NULL,
  size TEXT NOT NULL,
  quantity INTEGER NOT NULL CHECK (quantity > 0)
);

CREATE INDEX idx_order_items_order ON order_items(order_id);
```

### 2.3 Row Level Security (RLS) 정책

```sql
-- ============================================
-- RLS: hospitals
-- ============================================
ALTER TABLE hospitals ENABLE ROW LEVEL SECURITY;

-- 자신이 속한 병원만 조회 가능
CREATE POLICY "users_view_own_hospital" ON hospitals
  FOR SELECT USING (
    id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

-- master만 자신의 병원 수정 가능
CREATE POLICY "master_update_own_hospital" ON hospitals
  FOR UPDATE USING (master_admin_id = auth.uid());

-- 병원 검색을 위한 전체 목록 조회 (이름만)
CREATE POLICY "anyone_search_hospitals" ON hospitals
  FOR SELECT USING (true);

-- ============================================
-- RLS: profiles
-- ============================================
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- 자신의 프로필 조회/수정
CREATE POLICY "users_view_own_profile" ON profiles
  FOR SELECT USING (id = auth.uid());

CREATE POLICY "users_update_own_profile" ON profiles
  FOR UPDATE USING (id = auth.uid());

-- 같은 병원 멤버 조회 (구성원 관리용)
CREATE POLICY "hospital_members_viewable" ON profiles
  FOR SELECT USING (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

-- master가 같은 병원 멤버 상태 변경 (승인/거절)
CREATE POLICY "master_manage_members" ON profiles
  FOR UPDATE USING (
    hospital_id IN (
      SELECT h.id FROM hospitals h WHERE h.master_admin_id = auth.uid()
    )
  );

-- 가입 시 자신의 프로필 생성 (트리거가 처리하므로 service_role 사용)

-- ============================================
-- RLS: inventory (병원별 격리)
-- ============================================
ALTER TABLE inventory ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hospital_inventory_select" ON inventory
  FOR SELECT USING (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

CREATE POLICY "hospital_inventory_insert" ON inventory
  FOR INSERT WITH CHECK (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

CREATE POLICY "hospital_inventory_update" ON inventory
  FOR UPDATE USING (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

CREATE POLICY "hospital_inventory_delete" ON inventory
  FOR DELETE USING (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

-- ============================================
-- RLS: surgery_records (병원별 격리)
-- ============================================
ALTER TABLE surgery_records ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hospital_surgery_select" ON surgery_records
  FOR SELECT USING (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

CREATE POLICY "hospital_surgery_insert" ON surgery_records
  FOR INSERT WITH CHECK (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

CREATE POLICY "hospital_surgery_update" ON surgery_records
  FOR UPDATE USING (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

-- ============================================
-- RLS: orders (병원별 격리)
-- ============================================
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hospital_orders_select" ON orders
  FOR SELECT USING (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

CREATE POLICY "hospital_orders_insert" ON orders
  FOR INSERT WITH CHECK (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

CREATE POLICY "hospital_orders_update" ON orders
  FOR UPDATE USING (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

CREATE POLICY "hospital_orders_delete" ON orders
  FOR DELETE USING (
    hospital_id IN (SELECT hospital_id FROM profiles WHERE id = auth.uid())
  );

-- ============================================
-- RLS: order_items (orders를 통한 간접 격리)
-- ============================================
ALTER TABLE order_items ENABLE ROW LEVEL SECURITY;

CREATE POLICY "order_items_via_orders" ON order_items
  FOR SELECT USING (
    order_id IN (
      SELECT id FROM orders WHERE hospital_id IN (
        SELECT hospital_id FROM profiles WHERE id = auth.uid()
      )
    )
  );

CREATE POLICY "order_items_insert" ON order_items
  FOR INSERT WITH CHECK (
    order_id IN (
      SELECT id FROM orders WHERE hospital_id IN (
        SELECT hospital_id FROM profiles WHERE id = auth.uid()
      )
    )
  );

CREATE POLICY "order_items_delete" ON order_items
  FOR DELETE USING (
    order_id IN (
      SELECT id FROM orders WHERE hospital_id IN (
        SELECT hospital_id FROM profiles WHERE id = auth.uid()
      )
    )
  );
```

### 2.4 Supabase Storage 버킷

```sql
-- 사업자등록증 파일 (회원가입 시 업로드)
INSERT INTO storage.buckets (id, name, public)
VALUES ('biz-documents', 'biz-documents', false);

-- 엑셀 파일 백업 (선택적)
INSERT INTO storage.buckets (id, name, public)
VALUES ('excel-backups', 'excel-backups', false);

-- Storage RLS
CREATE POLICY "users_upload_own_biz_doc" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'biz-documents' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY "users_view_own_biz_doc" ON storage.objects
  FOR SELECT USING (
    bucket_id = 'biz-documents' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );
```

## 3. 타입 정의 (TypeScript)

### 3.1 Supabase 연동 타입 추가 (types.ts 확장)

```typescript
// ============================================
// Supabase Database Types (auto-generated 대응)
// ============================================

/** Supabase hospitals 테이블 Row */
export interface DbHospital {
  id: string;
  name: string;
  master_admin_id: string | null;
  phone: string | null;
  biz_file_url: string | null;
  created_at: string;
  updated_at: string;
}

/** Supabase profiles 테이블 Row */
export interface DbProfile {
  id: string;
  email: string;
  name: string;
  role: UserRole;
  hospital_id: string | null;
  status: 'pending' | 'active';
  created_at: string;
  updated_at: string;
}

/** Supabase inventory 테이블 Row */
export interface DbInventoryItem {
  id: string;
  hospital_id: string;
  manufacturer: string;
  brand: string;
  size: string;
  initial_stock: number;
  created_at: string;
  updated_at: string;
}

/** Supabase surgery_records 테이블 Row */
export interface DbSurgeryRecord {
  id: string;
  hospital_id: string;
  date: string | null;
  patient_info: string | null;
  tooth_number: string | null;
  quantity: number;
  surgery_record: string | null;
  classification: string;
  manufacturer: string | null;
  brand: string | null;
  size: string | null;
  bone_quality: string | null;
  initial_fixation: string | null;
  healing: string | null;
  next_visit: string | null;
  created_at: string;
}

/** Supabase orders 테이블 Row */
export interface DbOrder {
  id: string;
  hospital_id: string;
  type: OrderType;
  manufacturer: string;
  date: string;
  manager: string;
  status: OrderStatus;
  received_date: string | null;
  created_at: string;
}

/** Supabase order_items 테이블 Row */
export interface DbOrderItem {
  id: string;
  order_id: string;
  brand: string;
  size: string;
  quantity: number;
}

// ============================================
// 매핑 유틸 타입 (DB ↔ Frontend)
// ============================================

/** DB → Frontend 변환 함수 시그니처 */
export type DbToFrontend<TDb, TFe> = (dbRow: TDb) => TFe;
export type FrontendToDb<TFe, TDb> = (feItem: TFe) => Partial<TDb>;
```

### 3.2 기존 타입과 DB 타입 매핑

| Frontend 타입 | DB 타입 | 변환 포인트 |
|--------------|---------|------------|
| `Hospital` | `DbHospital` | `id` (string → UUID), `masterAdminId` → `master_admin_id` |
| `User` | `DbProfile` | `email` PK → `id` (UUID) PK, `hospitalId` → `hospital_id` |
| `InventoryItem` | `DbInventoryItem` | `usageCount`, `currentStock`, `recommendedStock`는 **계산 필드** (DB 미저장) |
| `Order` + `OrderItem[]` | `DbOrder` + `DbOrderItem[]` | `items` 배열 → 별도 테이블 정규화 |
| 수술기록 `ExcelRow` | `DbSurgeryRecord` | 비정형 Record → 정형 테이블 필드 |

### 3.3 계산 필드 처리 전략

```typescript
/**
 * InventoryItem의 계산 필드:
 * - usageCount: surgery_records에서 집계
 * - currentStock: initialStock + received - usageCount
 * - recommendedStock: max(dailyMax * 2, ceil(monthlyAvg))
 * - monthlyAvgUsage: totalUsage / periodInMonths
 * - dailyMaxUsage: max usage per day
 *
 * 이 필드들은 DB에 저장하지 않고 프론트엔드에서 계산한다.
 * 이유: 수술기록/주문 변경 시 자동 재계산 필요 (현재 syncInventoryWithUsageAndOrders 로직 유지)
 */
```

## 4. 서비스 레이어 설계

### 4.1 supabaseClient.ts

```typescript
// services/supabaseClient.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
  },
});
```

### 4.2 authService.ts

```typescript
// services/authService.ts
import { supabase } from './supabaseClient';
import { DbProfile, UserRole } from '../types';

interface SignupParams {
  email: string;
  password: string;
  name: string;
  role: UserRole;
  hospitalName?: string;  // master 전용
  phone?: string;         // master 전용
  bizFile?: File;         // master 전용
}

interface AuthResult {
  success: boolean;
  error?: string;
  profile?: DbProfile;
}

export const authService = {
  /** 이메일/비밀번호 회원가입 */
  async signUp(params: SignupParams): Promise<AuthResult>,

  /** 로그인 */
  async signIn(email: string, password: string): Promise<AuthResult>,

  /** 로그아웃 */
  async signOut(): Promise<void>,

  /** 현재 세션 조회 */
  async getSession(): Promise<Session | null>,

  /** 현재 사용자 프로필 조회 */
  async getCurrentProfile(): Promise<DbProfile | null>,

  /** 비밀번호 재설정 이메일 발송 */
  async resetPassword(email: string): Promise<{ success: boolean; error?: string }>,

  /** 프로필 업데이트 */
  async updateProfile(updates: Partial<DbProfile>): Promise<DbProfile | null>,

  /** 회원 탈퇴 (auth.users 삭제 → profiles CASCADE 삭제) */
  async deleteAccount(): Promise<{ success: boolean; error?: string }>,

  /** Auth 상태 변경 리스너 */
  onAuthStateChange(callback: (event: string, session: Session | null) => void): Subscription,
};
```

**회원가입 플로우 (Master/치과 회원):**

```
사용자 입력 → authService.signUp()
  → 1. supabase.auth.signUp({ email, password, options: { data: { name, role: 'master' }}})
  → 2. 트리거: on_auth_user_created → profiles INSERT (role='master', status='active')
  → 3. hospitals INSERT (name, master_admin_id, phone)
  → 4. profiles UPDATE (hospital_id = newHospital.id)
  → 5. Storage: bizFile 업로드 (biz-documents/{userId}/file)
  → 6. hospitals UPDATE (biz_file_url)
  → 반환: profile + session
```

**회원가입 플로우 (Staff/개인 회원):**

```
사용자 입력 → authService.signUp()
  → 1. supabase.auth.signUp({ email, password, options: { data: { name, role: 'staff' }}})
  → 2. 트리거: on_auth_user_created → profiles INSERT (role='staff', status='pending', hospital_id=null)
  → 반환: profile (hospital_id=null, status=pending)
  → 사용자: StaffWaitingRoom에서 병원 검색 → 가입 요청
```

### 4.3 hospitalService.ts

```typescript
// services/hospitalService.ts
export const hospitalService = {
  /** 병원 생성 (master 회원가입 시) */
  async createHospital(name: string, phone?: string): Promise<DbHospital>,

  /** 현재 사용자의 병원 정보 조회 */
  async getMyHospital(): Promise<DbHospital | null>,

  /** 병원 검색 (Staff가 가입할 병원 찾기) */
  async searchHospitals(query: string): Promise<DbHospital[]>,

  /** 병원 가입 요청 (Staff → 병원) */
  async requestJoin(hospitalId: string): Promise<void>,

  /** 병원 구성원 목록 조회 */
  async getMembers(hospitalId: string): Promise<DbProfile[]>,

  /** 가입 대기 멤버 조회 */
  async getPendingMembers(hospitalId: string): Promise<DbProfile[]>,

  /** 멤버 승인 */
  async approveMember(userId: string): Promise<void>,

  /** 멤버 거절/방출 */
  async rejectMember(userId: string): Promise<void>,

  /** 구성원 직접 추가 (Master) */
  async addMember(email: string, password: string, name: string): Promise<DbProfile>,

  /** 병원 탈퇴 */
  async leaveHospital(): Promise<void>,
};
```

### 4.4 inventoryService.ts

```typescript
// services/inventoryService.ts
export const inventoryService = {
  /** 재고 목록 조회 (RLS로 병원 자동 필터) */
  async getInventory(): Promise<DbInventoryItem[]>,

  /** 재고 항목 추가 */
  async addItem(item: Omit<DbInventoryItem, 'id' | 'created_at' | 'updated_at'>): Promise<DbInventoryItem>,

  /** 재고 항목 수정 */
  async updateItem(id: string, updates: Partial<DbInventoryItem>): Promise<DbInventoryItem>,

  /** 재고 항목 삭제 */
  async deleteItem(id: string): Promise<void>,

  /** 일괄 추가 (픽스쳐 데이터 → 재고 마스터 반영) */
  async bulkInsert(items: Omit<DbInventoryItem, 'id' | 'created_at' | 'updated_at'>[]): Promise<DbInventoryItem[]>,

  /** Realtime 구독 (재고 변경 시 콜백) */
  subscribeToChanges(callback: (payload: RealtimePayload) => void): RealtimeChannel,
};
```

### 4.5 surgeryService.ts

```typescript
// services/surgeryService.ts
export const surgeryService = {
  /** 수술기록 목록 조회 (병원별 RLS) */
  async getSurgeryRecords(): Promise<DbSurgeryRecord[]>,

  /** 엑셀 파싱 후 수술기록 일괄 저장 */
  async bulkInsertFromExcel(
    parsedRows: ExcelRow[],
    hospitalId: string
  ): Promise<DbSurgeryRecord[]>,

  /** 수술기록 셀 수정 */
  async updateRecord(id: string, updates: Partial<DbSurgeryRecord>): Promise<DbSurgeryRecord>,

  /** FAIL 교환 완료 처리 (classification 변경) */
  async markFailExchanged(recordIds: string[]): Promise<void>,

  /** 사용량 통계 조회 (inventorySync용) */
  async getUsageStats(hospitalId: string): Promise<{
    byItem: Record<string, { total: number; dailyMax: number; monthlyAvg: number }>;
    periodMonths: number;
  }>,
};
```

### 4.6 orderService.ts

```typescript
// services/orderService.ts
export const orderService = {
  /** 주문 목록 조회 (order_items JOIN) */
  async getOrders(): Promise<(DbOrder & { items: DbOrderItem[] })[]>,

  /** 주문 생성 (order + items 트랜잭션) */
  async createOrder(
    order: Omit<DbOrder, 'id' | 'created_at'>,
    items: Omit<DbOrderItem, 'id' | 'order_id'>[]
  ): Promise<DbOrder>,

  /** 주문 상태 변경 (ordered → received) */
  async updateStatus(orderId: string, status: OrderStatus, receivedDate?: string): Promise<void>,

  /** 주문 삭제 (CASCADE로 items도 삭제) */
  async deleteOrder(orderId: string): Promise<void>,
};
```

### 4.7 migrationService.ts

```typescript
// services/migrationService.ts
export const migrationService = {
  /** localStorage 데이터 존재 여부 확인 */
  hasLocalData(hospitalId: string): boolean,

  /** localStorage → Supabase 전체 마이그레이션 */
  async migrateAll(hospitalId: string): Promise<MigrationResult>,

  /** 개별 테이블 마이그레이션 */
  async migrateInventory(hospitalId: string): Promise<number>,
  async migrateSurgeryRecords(hospitalId: string): Promise<number>,
  async migrateOrders(hospitalId: string): Promise<number>,

  /** 마이그레이션 후 localStorage 정리 */
  clearLocalData(hospitalId: string): void,
};

interface MigrationResult {
  inventory: { migrated: number; errors: number };
  surgery: { migrated: number; errors: number };
  orders: { migrated: number; errors: number };
  success: boolean;
}
```

## 5. 인증 플로우 설계

### 5.1 로그인 플로우

```
[AuthForm: Login]
     │
     ▼
authService.signIn(email, password)
     │
     ▼
supabase.auth.signInWithPassword()
     │
     ├── 실패 → ErrorMessage 표시
     │
     ▼ 성공
authService.getCurrentProfile()
     │
     ▼
supabase.from('profiles').select('*').eq('id', user.id)
     │
     ├── profile.status === 'pending' && profile.hospital_id
     │   → StaffWaitingRoom (승인 대기)
     │
     ├── profile.status === 'pending' && !profile.hospital_id
     │   → StaffWaitingRoom (병원 검색)
     │
     ├── profile.role === 'master' && isAdmin(email)
     │   → SystemAdminDashboard
     │
     └── profile.status === 'active'
         → Dashboard (병원 데이터 로드)
```

### 5.2 세션 관리

```typescript
// App.tsx (변경 후)
useEffect(() => {
  // 1. 초기 세션 복원
  supabase.auth.getSession().then(({ data: { session } }) => {
    if (session) loadUserProfile(session.user.id);
  });

  // 2. Auth 상태 변경 리스너
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    async (event, session) => {
      if (event === 'SIGNED_IN' && session) {
        await loadUserProfile(session.user.id);
      } else if (event === 'SIGNED_OUT') {
        clearAppState();
      } else if (event === 'TOKEN_REFRESHED') {
        // 토큰 자동 갱신 완료 (별도 처리 불필요)
      }
    }
  );

  return () => subscription.unsubscribe();
}, []);
```

### 5.3 Admin 판별 변경

```
현재 (As-Is):
  email === 'admin' || 'admin@admin.com' || 'admin@test.com'

목표 (To-Be):
  Supabase에서도 동일 로직 유지 (하드코딩)
  + profiles.role === 'master' 기반 확장

  const isAdmin = user?.email === 'admin@admin.com'
    || user?.email === 'admin@test.com'
    || user?.app_metadata?.role === 'admin';
```

## 6. 컴포넌트 수정 설계

### 6.1 App.tsx 수정 범위

| 영역 | 현재 | 변경 후 |
|------|------|---------|
| 초기 상태 로드 | `localStorage.getItem()` | `supabase.auth.getSession()` + DB SELECT |
| 사용자 세션 | `app_user` localStorage | `supabase.auth.onAuthStateChange()` |
| 데이터 영속화 | `useEffect → localStorage.setItem()` | Supabase 실시간 CRUD (서비스 호출) |
| 로그인 성공 | `handleLoginSuccess()` localStorage 로드 | `handleLoginSuccess()` DB 로드 |
| 로그아웃 | `localStorage.removeItem()` | `supabase.auth.signOut()` |
| 재고 동기화 | `syncInventoryWithUsageAndOrders()` | **유지** (계산 로직은 프론트엔드) |

**핵심 변경:**

```typescript
// 기존: localStorage 영속화 useEffect 4개 제거
// useEffect(() => { localStorage.setItem(...) }, [state.inventory]) → 삭제

// 신규: Supabase에서 데이터 로드
const loadHospitalData = async (hospitalId: string) => {
  const [inventory, surgeryRecords, orders] = await Promise.all([
    inventoryService.getInventory(),
    surgeryService.getSurgeryRecords(),
    orderService.getOrders(),
  ]);

  setState(prev => ({
    ...prev,
    inventory: inventory.map(dbToInventoryItem),
    surgeryMaster: { '수술기록지': surgeryRecords.map(dbToExcelRow) },
    orders: orders.map(dbToOrder),
  }));
};
```

### 6.2 AuthForm.tsx 수정 범위

| 영역 | 현재 | 변경 후 |
|------|------|---------|
| 회원가입 | `localStorage → app_users` | `authService.signUp()` |
| 로그인 | `localStorage.find(email, password)` | `authService.signIn()` |
| 비밀번호 저장 | `(user as any).password` 평문 | Supabase Auth 자동 해싱 |
| 이메일 중복 | `localStorage 목록 검색` | Supabase Auth 자동 처리 |
| 비밀번호 확인 | 프론트엔드 검증 (유지) | **유지** (UX용) |
| 사업자등록증 | `bizFile` 상태만 (실제 미저장) | Storage 업로드 |
| Admin 백도어 | `admin/admin123` 하드코딩 | 제거 또는 환경변수 기반 |

### 6.3 MemberManager.tsx 수정 범위

```
현재:
  localStorage.getItem('app_users') → 필터 → 렌더

변경:
  hospitalService.getMembers(hospitalId) → 렌더
  hospitalService.getPendingMembers(hospitalId) → 렌더
  hospitalService.approveMember(userId) → 승인
  hospitalService.rejectMember(userId) → 거절
  hospitalService.addMember(email, password, name) → 추가
```

### 6.4 StaffWaitingRoom.tsx 수정 범위

```
현재:
  localStorage.getItem('app_hospitals') → 검색 필터
  localStorage 직접 수정 (hospitalId 설정)

변경:
  hospitalService.searchHospitals(query) → 검색
  hospitalService.requestJoin(hospitalId) → 가입 요청
  handleCancelRequest → authService.updateProfile({ hospital_id: null })
```

### 6.5 InventoryManager.tsx 수정 범위

```
현재:
  props.inventory (App.tsx 상태에서 전달)
  props.onUpdateStock → setState

변경 (Phase 1 - Minimal):
  props 인터페이스 유지 (App.tsx가 DB에서 로드한 데이터 전달)
  onUpdateStock → inventoryService.updateItem() + setState
  onDeleteInventoryItem → inventoryService.deleteItem() + setState
  onAddInventoryItem → inventoryService.addItem() + setState
```

### 6.6 OrderManager.tsx, FailManager.tsx 수정 범위

```
동일 패턴:
  props 인터페이스 유지
  CRUD 콜백에서 서비스 호출 추가
  성공 시 setState로 로컬 상태 업데이트
```

### 6.7 DashboardOverview.tsx 수정 범위

```
변경 없음 (최소):
  props로 전달받는 데이터는 App.tsx에서 이미 DB 연동된 상태
  통계 계산 로직은 프론트엔드 유지
```

## 7. 데이터 매핑 함수

### 7.1 DB → Frontend 변환

```typescript
// services/mappers.ts

/** DbInventoryItem → InventoryItem (계산 필드 초기값 포함) */
export function dbToInventoryItem(db: DbInventoryItem): InventoryItem {
  return {
    id: db.id,
    manufacturer: db.manufacturer,
    brand: db.brand,
    size: db.size,
    initialStock: db.initial_stock,
    usageCount: 0,        // syncInventoryWithUsageAndOrders에서 재계산
    currentStock: db.initial_stock,  // 재계산 예정
    recommendedStock: 0,   // 재계산 예정
  };
}

/** DbSurgeryRecord → ExcelRow (기존 수술기록지 포맷 호환) */
export function dbToExcelRow(db: DbSurgeryRecord): ExcelRow {
  return {
    '날짜': db.date || '',
    '환자정보': db.patient_info || '',
    '치아번호': db.tooth_number || '',
    '갯수': db.quantity,
    '수술기록': db.surgery_record || '',
    '구분': db.classification,
    '제조사': db.manufacturer || '',
    '브랜드': db.brand || '',
    '규격(SIZE)': db.size || '',
    '골질': db.bone_quality || '',
    '초기고정': db.initial_fixation || '',
    '힐링': db.healing || '',
    '다음 진료': db.next_visit || '',
    _id: db.id,  // DB ID 보존 (업데이트용)
  };
}

/** DbOrder + DbOrderItem[] → Order */
export function dbToOrder(db: DbOrder & { items: DbOrderItem[] }): Order {
  return {
    id: db.id,
    type: db.type,
    manufacturer: db.manufacturer,
    date: db.date,
    items: db.items.map(i => ({
      brand: i.brand,
      size: i.size,
      quantity: i.quantity,
    })),
    manager: db.manager,
    status: db.status,
    receivedDate: db.received_date || undefined,
  };
}
```

### 7.2 Frontend → DB 변환

```typescript
/** InventoryItem → DbInventoryItem INSERT용 */
export function inventoryToDb(
  item: InventoryItem,
  hospitalId: string
): Omit<DbInventoryItem, 'id' | 'created_at' | 'updated_at'> {
  return {
    hospital_id: hospitalId,
    manufacturer: item.manufacturer,
    brand: item.brand,
    size: item.size,
    initial_stock: item.initialStock,
  };
}

/** ExcelRow → DbSurgeryRecord INSERT용 */
export function excelRowToDbSurgery(
  row: ExcelRow,
  hospitalId: string
): Omit<DbSurgeryRecord, 'id' | 'created_at'> {
  return {
    hospital_id: hospitalId,
    date: row['날짜'] || null,
    patient_info: row['환자정보'] || null,
    tooth_number: row['치아번호'] || null,
    quantity: Number(row['갯수']) || 1,
    surgery_record: row['수술기록'] || null,
    classification: row['구분'] || '식립',
    manufacturer: row['제조사'] || null,
    brand: row['브랜드'] || null,
    size: row['규격(SIZE)'] || null,
    bone_quality: row['골질'] || null,
    initial_fixation: row['초기고정'] || null,
    healing: row['힐링'] || null,
    next_visit: row['다음 진료'] || null,
  };
}

/** Order → DbOrder + DbOrderItem[] INSERT용 */
export function orderToDb(
  order: Order,
  hospitalId: string
): {
  order: Omit<DbOrder, 'id' | 'created_at'>;
  items: Omit<DbOrderItem, 'id' | 'order_id'>[];
} {
  return {
    order: {
      hospital_id: hospitalId,
      type: order.type,
      manufacturer: order.manufacturer,
      date: order.date,
      manager: order.manager,
      status: order.status,
      received_date: order.receivedDate || null,
    },
    items: order.items.map(i => ({
      brand: i.brand,
      size: i.size,
      quantity: i.quantity,
    })),
  };
}
```

## 8. Realtime 구독 설계

### 8.1 구독 대상

```typescript
// App.tsx 또는 hooks/useRealtime.ts
const subscribeToHospitalData = (hospitalId: string) => {
  // 재고 변경 구독
  const inventoryChannel = supabase
    .channel('inventory-changes')
    .on('postgres_changes', {
      event: '*',
      schema: 'public',
      table: 'inventory',
      filter: `hospital_id=eq.${hospitalId}`,
    }, (payload) => {
      handleInventoryChange(payload);
    })
    .subscribe();

  // 수술기록 변경 구독
  const surgeryChannel = supabase
    .channel('surgery-changes')
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'surgery_records',
      filter: `hospital_id=eq.${hospitalId}`,
    }, (payload) => {
      handleSurgeryInsert(payload);
    })
    .subscribe();

  // 주문 변경 구독
  const ordersChannel = supabase
    .channel('orders-changes')
    .on('postgres_changes', {
      event: '*',
      schema: 'public',
      table: 'orders',
      filter: `hospital_id=eq.${hospitalId}`,
    }, (payload) => {
      handleOrderChange(payload);
    })
    .subscribe();

  return () => {
    supabase.removeChannel(inventoryChannel);
    supabase.removeChannel(surgeryChannel);
    supabase.removeChannel(ordersChannel);
  };
};
```

### 8.2 변경 이벤트 처리

```
INSERT → 로컬 상태에 추가 (중복 확인 후)
UPDATE → 로컬 상태에서 해당 항목 갱신
DELETE → 로컬 상태에서 해당 항목 제거

* syncInventoryWithUsageAndOrders()는 surgery/orders 변경 시 자동 재실행
```

## 9. 환경 변수 설계

### 9.1 .env.local 파일

```env
# Supabase
VITE_SUPABASE_URL=https://[PROJECT_ID].supabase.co
VITE_SUPABASE_ANON_KEY=[anon-public-key]

# 기존 유지
GEMINI_API_KEY=[gemini-key-if-used]
```

### 9.2 .env.example 파일

```env
# Supabase Configuration
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key

# Optional
GEMINI_API_KEY=your-gemini-key
```

### 9.3 vite.config.ts 수정

```typescript
// VITE_ 접두사가 있는 env는 자동으로 import.meta.env에 노출
// 별도 define 설정 불필요 (기존 GEMINI_API_KEY 설정 유지)
```

## 10. 구현 순서

### Phase 1: 인프라 세팅 (B-12, B-25)

```
1. npm install @supabase/supabase-js
2. .env.local 생성 (Supabase URL + Anon Key)
3. .env.example 생성 (템플릿)
4. .gitignore에 .env.local 추가
5. services/supabaseClient.ts 생성
6. types.ts에 Db* 타입 추가
7. services/mappers.ts 생성
```

**검증**: `supabase.from('hospitals').select('count')` 호출 성공

### Phase 2: Auth 연동 (B-01~B-05, B-13)

```
8. services/authService.ts 생성
9. AuthForm.tsx 수정 (signUp/signIn 연동)
10. App.tsx 세션 관리 수정 (onAuthStateChange)
11. Admin 백도어 처리 결정
```

**검증**: 회원가입 → Supabase Auth 대시보드에 사용자 생성 확인

### Phase 3: DB 스키마 (B-06~B-11, B-23~B-24)

```
12. Supabase SQL Editor에서 테이블 생성 (6개)
13. 트리거 함수 생성 (handle_new_user)
14. RLS 정책 적용
15. 인덱스 생성
16. Storage 버킷 생성
```

**검증**: Supabase 대시보드에서 테이블/RLS 확인

### Phase 4: 핵심 서비스 (B-14~B-17)

```
17. services/hospitalService.ts 생성
18. services/inventoryService.ts 생성
19. services/surgeryService.ts 생성
20. services/orderService.ts 생성
```

**검증**: 각 서비스의 CRUD 함수 단독 호출 테스트

### Phase 5: 컴포넌트 연동

```
21. App.tsx: localStorage 영속화 제거, DB 로드 함수 추가
22. App.tsx: handleFileUpload → surgeryService.bulkInsertFromExcel 연동
23. App.tsx: handleAddOrder → orderService.createOrder 연동
24. App.tsx: handleUpdateOrderStatus → orderService.updateStatus 연동
25. MemberManager.tsx: hospitalService 연동
26. StaffWaitingRoom.tsx: hospitalService 연동
27. UserProfile.tsx: authService 연동 (탈퇴, 프로필 수정)
28. InventoryManager.tsx: CRUD 콜백에 서비스 호출 추가
```

**검증**: 전체 CRUD 플로우 동작 (UI → DB → UI 반영)

### Phase 6: 동기화 및 스토리지 (B-18~B-22)

```
29. services/migrationService.ts 생성
30. 마이그레이션 UI 추가 (Settings 또는 프로필 내)
31. Realtime 구독 설정
32. 사업자등록증 Storage 업로드 연동
```

**검증**: localStorage 데이터 → Supabase 마이그레이션 성공

### Phase 7: 정리

```
33. localStorage 의존성 제거 (마이그레이션 완료 후)
34. 불필요한 코드 정리
35. 에러 핸들링 강화 (네트워크 오류, RLS 오류 등)
36. 최종 통합 테스트
```

## 11. 에러 핸들링 설계

### 11.1 에러 타입

```typescript
// types.ts 추가
export interface ServiceError {
  code: string;
  message: string;
  details?: string;
}

// 공통 에러 코드
const ERROR_CODES = {
  AUTH_INVALID_CREDENTIALS: '아이디 또는 비밀번호가 일치하지 않습니다.',
  AUTH_EMAIL_EXISTS: '이미 등록된 이메일입니다.',
  AUTH_WEAK_PASSWORD: '비밀번호가 너무 약합니다.',
  AUTH_SESSION_EXPIRED: '세션이 만료되었습니다. 다시 로그인해주세요.',
  RLS_VIOLATION: '접근 권한이 없습니다.',
  NETWORK_ERROR: '네트워크 연결을 확인해주세요.',
  UNKNOWN: '알 수 없는 오류가 발생했습니다.',
} as const;
```

### 11.2 서비스 레이어 에러 처리

```typescript
// 각 서비스 함수의 에러 처리 패턴
async function serviceCall() {
  const { data, error } = await supabase.from('table').select();
  if (error) {
    console.error('[ServiceName]', error);
    throw new ServiceError(error.code, error.message);
  }
  return data;
}
```

### 11.3 컴포넌트 레벨 에러 처리

```
try {
  await inventoryService.addItem(newItem);
  setState(prev => ({ ...prev, inventory: [...prev.inventory, newItem] }));
} catch (error) {
  alert(getErrorMessage(error));
  // 로컬 상태 롤백 불필요 (성공 시만 setState)
}
```

## 12. 파일 변경 목록

### 12.1 신규 파일

| # | 파일 | 역할 | 예상 줄수 |
|:-:|------|------|:--------:|
| 1 | `services/supabaseClient.ts` | Supabase 클라이언트 초기화 | ~15 |
| 2 | `services/authService.ts` | 인증 서비스 | ~150 |
| 3 | `services/hospitalService.ts` | 병원 관리 서비스 | ~120 |
| 4 | `services/inventoryService.ts` | 재고 관리 서비스 | ~80 |
| 5 | `services/surgeryService.ts` | 수술기록 서비스 | ~120 |
| 6 | `services/orderService.ts` | 주문 관리 서비스 | ~100 |
| 7 | `services/migrationService.ts` | localStorage→Supabase 마이그레이션 | ~150 |
| 8 | `services/mappers.ts` | DB ↔ Frontend 데이터 매핑 | ~120 |
| 9 | `.env.local` | Supabase 환경변수 | ~5 |
| 10 | `.env.example` | 환경변수 템플릿 | ~5 |

### 12.2 수정 파일

| # | 파일 | 변경 내용 | 영향도 |
|:-:|------|-----------|:------:|
| 1 | `App.tsx` | 세션 관리, localStorage 제거, DB 로드 | High |
| 2 | `components/AuthForm.tsx` | Supabase Auth 연동 | High |
| 3 | `components/MemberManager.tsx` | hospitalService 연동 | Medium |
| 4 | `components/StaffWaitingRoom.tsx` | hospitalService 연동 | Medium |
| 5 | `components/UserProfile.tsx` | authService 연동 | Medium |
| 6 | `components/InventoryManager.tsx` | CRUD 서비스 콜백 | Low |
| 7 | `components/OrderManager.tsx` | CRUD 서비스 콜백 | Low |
| 8 | `components/FailManager.tsx` | CRUD 서비스 콜백 | Low |
| 9 | `components/DashboardOverview.tsx` | 최소 변경 (props 유지) | Low |
| 10 | `types.ts` | Db* 타입 추가, showProfile 보완 | Medium |
| 11 | `package.json` | @supabase/supabase-js 추가 | Low |
| 12 | `vite.config.ts` | env 설정 확인 (변경 없을 수 있음) | Low |

## 13. 기존 로직 보존 항목

다음 핵심 로직은 **변경 없이 유지**:

| 로직 | 파일 | 이유 |
|------|------|------|
| `syncInventoryWithUsageAndOrders()` | `App.tsx:241-325` | 계산 필드는 프론트엔드 책임 |
| `handleFileUpload()` 파싱 로직 | `App.tsx:331-427` | 엑셀 파싱은 클라이언트 사이드 유지 |
| `sizeNormalizer.ts` 전체 | `services/sizeNormalizer.ts` | 규격 파싱은 변경 불필요 |
| `excelService.ts` 전체 | `services/excelService.ts` | 엑셀 I/O는 변경 불필요 |
| `analysisService.ts` 전체 | `services/analysisService.ts` | 진단 로직은 변경 불필요 |
| FAIL 교환 플로우 | `App.tsx:436-462` | 로직 유지, DB 연동만 추가 |
| 비밀번호 검증 규칙 | `AuthForm.tsx:62-66` | UX 검증은 프론트엔드 유지 |

## 14. 보안 설계

### 14.1 인증 보안

| 항목 | 설계 |
|------|------|
| 비밀번호 해싱 | Supabase Auth 자동 (bcrypt) |
| JWT 토큰 | Access Token (1h) + Refresh Token (7d) |
| 세션 자동 갱신 | `autoRefreshToken: true` |
| HTTPS | Supabase Cloud 기본 제공 |

### 14.2 데이터 보안

| 항목 | 설계 |
|------|------|
| 병원 데이터 격리 | RLS: `hospital_id = user's hospital_id` |
| API 키 보호 | `.env.local` (git 미추적) |
| Anon Key 노출 | RLS가 보호하므로 안전 (Supabase 공식 패턴) |
| Admin 접근 | `service_role` 키는 서버 전용 (프론트엔드 미사용) |

### 14.3 기존 보안 취약점 해소

| 취약점 | 현재 | 해결 |
|--------|------|------|
| 비밀번호 평문 저장 | `(user as any).password` | Supabase Auth 자동 해싱 |
| 클라이언트 인증 | `localStorage.find()` | JWT 기반 서버 검증 |
| Admin 백도어 | `admin/admin123` 하드코딩 | 제거 또는 환경변수 |
| 데이터 변조 | localStorage 직접 수정 가능 | RLS로 서버 레벨 보호 |

---

**Created**: 2026-02-15
**Level**: Dynamic
**Phase**: Design
**Plan Reference**: `docs/01-plan/features/백엔드-연동.plan.md`
**Features**: B-01 ~ B-25 (25개)
